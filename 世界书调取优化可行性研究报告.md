# 世界书调取优化可行性研究报告

## 需求概述

当以下特定世界书库中的词条**第一次被调取**时，AI必须按照世界书条目的要求**详细描写**：
- 生活细节库（internal_basic_procedures）
- 法律细节库（internal_basic_legal）
- 专业知识库（legal_knowledge）
- 核心规则库（detention_rules）
- 环境描写库（environment_descriptions）

当后续**重复被调取**时，则可以**简化描写**。

## 当前系统架构分析

### 1. 世界书系统工作原理

根据代码分析，当前系统的工作流程如下：

```
用户输入 → 酒馆世界书系统自动匹配关键词 → 激活匹配的条目 →
条目的content直接注入到提示词 → AI生成回复
```

**关键发现**：
- 世界书条目的激活由**酒馆本身**根据 `strategy` 和 `keys` 自动完成
- 条目的 `content` 在激活时**直接注入**到提示词中
- 我们的 `worldbook_loader.ts` 只负责**加载世界书到角色卡**，不负责追踪激活

### 2. 当前代码能力

**已有的能力**：
- ✅ 可以加载/卸载世界书
- ✅ 可以读取世界书条目内容（通过 `getWorldbook()` API）
- ✅ 可以修改世界书条目（通过 `replaceWorldbook()` / `updateWorldbookWith()` API）
- ✅ 可以监听 AI 生成过程（`GENERATION_STARTED` / `GENERATION_ENDED` 事件）

**缺失的能力**：
- ❌ 无法直接检测哪些世界书条目被激活（这是酒馆内部逻辑）
- ❌ 无法在条目激活时拦截或修改其 content
- ❌ 无法直接访问注入到提示词中的完整内容

## 实现方案分析

### 方案A：动态修改世界书条目（推荐度：⭐⭐⭐⭐）

**原理**：
- 在加载世界书时，为每个条目创建**详细版本**和**简化版本**
- 使用 `extra` 字段存储简化版本内容
- 监听 `GENERATION_STARTED` 事件，在生成前动态替换条目内容

**实现步骤**：
1. 在 `_loadWorldbookInternal` 中，为指定世界书库的每个条目：
   - 保存原始详细内容到 `entry.content`
   - 生成简化版本（通过AI或预设模板）存储到 `entry.extra.simplified`
   - 记录条目的唯一标识（`worldbook_name + entry.uid`）

2. 维护一个追踪表（存储在聊天变量中）：
   ```typescript
   interface ActivatedEntries {
     [entryKey: string]: {
       firstActivatedDay: number;
       activatedCount: number;
       lastActivatedDay: number;
     };
   }
   ```

3. 监听 `GENERATION_STARTED` 事件：
   - 读取当前提示词（如果API可用）或通过其他方式检测
   - 通过关键词匹配识别哪些条目可能被激活
   - 检查追踪表，判断是否是首次激活
   - 如果是重复激活，使用 `updateWorldbookWith` 临时替换条目内容为简化版本

4. 监听 `GENERATION_ENDED` 事件：
   - 将条目内容恢复为详细版本
   - 更新追踪表

**优点**：
- ✅ 不侵入酒馆核心逻辑
- ✅ 可以精确控制哪些条目需要简化
- ✅ 状态持久化，聊天重启后仍然有效

**缺点**：
- ⚠️ 需要精确识别哪些条目被激活（可能需要关键词匹配）
- ⚠️ 频繁修改世界书可能有性能开销
- ⚠️ 简化版本需要预先生成或设计模板

**可行性评估**：**高** - 技术可行，但需要处理细节

---

### 方案B：通过提示词注入控制指令（推荐度：⭐⭐⭐⭐⭐）

**原理**：
- 不在生成时修改世界书条目本身
- 而是在提示词中注入**控制指令**，告诉AI如何根据条目是否首次调取来决定描写详细程度
- 使用世界书的 `extra` 字段存储条目的"简化提示"

**实现步骤**：
1. 在加载世界书时，为每个指定库的条目添加元数据：
   ```typescript
   entry.extra = {
     ...entry.extra,
     simplifiedHint: "这是该条目的简化版本提示，后续调取时使用简化描写",
     isFirstTimeLibrary: true, // 标记这是需要"首次详细"的库
   }
   ```

2. 在系统提示词或角色卡定义中添加规则：
   ```
   当调取以下世界书库的条目时：
   - 生活细节库
   - 法律细节库
   - 专业知识库
   - 核心规则库
   - 环境描写库

   如果该条目是第一次被调取，必须详细描写。
   如果是重复调取，可以简化描写，只需简要提及即可。
   ```

3. 通过监听消息，在特定位置注入追踪信息：
   - 在用户消息或系统消息中添加隐藏标记，记录本次回复中可能激活的条目
   - AI生成时根据这些标记决定详细程度

**优点**：
- ✅ 不需要频繁修改世界书
- ✅ 利用AI的理解能力，更灵活
- ✅ 实现相对简单

**缺点**：
- ⚠️ 依赖AI正确理解指令（可能不稳定）
- ⚠️ 需要AI模型支持这种"首次/重复"的逻辑判断
- ⚠️ 无法强制保证AI一定会遵循

**可行性评估**：**中高** - 技术可行，但依赖AI理解能力

---

### 方案C：混合方案 - 条目内容双重存储（推荐度：⭐⭐⭐⭐⭐）

**原理**：
- 在加载世界书时为每个条目创建**两个版本**：详细版和简化版
- 详细版存储在 `entry.content`
- 简化版存储在 `entry.extra.simplifiedContent`
- 通过动态替换条目内容实现

**实现步骤**：
1. 扩展 `WorldbookLoader` 接口，添加方法：
   ```typescript
   interface WorldbookLoaderImpl {
     // ... 现有方法
     trackEntryActivation(entryKey: string): void;
     getEntryContent(entryKey: string, isFirstTime: boolean): string;
     updateEntryContentForGeneration(): Promise<void>;
   }
   ```

2. 在 `_loadWorldbookInternal` 中：
   - 为指定库的每个条目生成简化版本（通过AI生成或预设模板）
   - 存储到 `entry.extra.simplifiedContent`
   - 标记条目需要追踪

3. 创建追踪系统（存储在聊天变量）：
   ```typescript
   interface EntryActivationTracker {
     // entryKey格式: "worldbookName_entryUid" 或 "worldbookName_entryName"
     activatedEntries: Set<string>;
     firstActivationDay: Map<string, number>;
   }
   ```

4. 在 `GENERATION_STARTED` 时：
   - 通过 `getWorldbook()` 获取所有已加载的世界书
   - 根据当前上下文（用户输入、聊天历史）预测可能激活的条目
   - 检查追踪表，判断是否是首次激活
   - 如果不是首次，使用 `updateWorldbookWith` 临时将条目content替换为简化版本

5. 在 `GENERATION_ENDED` 时：
   - 恢复所有条目的详细版本
   - 更新追踪表，标记新激活的条目

6. 简化版本生成策略：
   - **方案C1**：使用AI生成（调用LLM API生成简化版）
   - **方案C2**：使用预设模板（为每个条目类型设计简化模板）
   - **方案C3**：提取关键信息（从详细版本中提取前100-200字作为简化版）

**优点**：
- ✅ 可以精确控制内容
- ✅ 不依赖AI理解指令
- ✅ 可以强制保证简化描写

**缺点**：
- ⚠️ 需要生成简化版本（可能需要额外资源）
- ⚠️ 需要精确预测哪些条目会被激活（可能有误差）
- ⚠️ 频繁修改世界书可能有性能问题

**可行性评估**：**高** - 技术可行，需要仔细设计

---

### 方案D：基于消息内容的智能检测（推荐度：⭐⭐⭐）

**原理**：
- 在 `GENERATION_STARTED` 时，尝试获取当前提示词内容
- 通过正则或关键词匹配，识别哪些世界书条目被注入
- 根据追踪表决定是否需要在提示词中添加"简化描写"指令

**实现步骤**：
1. 监听 `GENERATION_STARTED` 事件
2. 尝试获取当前提示词（如果API可用）
3. 通过条目名称或关键词匹配识别激活的条目
4. 检查追踪表，如果是重复激活，在提示词末尾添加：
   ```
   [注意：本次回复中涉及的世界书条目之前已经详细描写过，请使用简化描写，简要提及即可]
   ```
5. 更新追踪表

**优点**：
- ✅ 不需要修改世界书条目本身
- ✅ 实现相对简单

**缺点**：
- ❌ 可能无法获取提示词内容（API限制）
- ⚠️ 关键词匹配可能不准确
- ⚠️ 依赖AI理解指令

**可行性评估**：**中** - 技术可行，但可能受API限制

---

## 推荐方案：方案C（混合方案）

### 为什么推荐方案C？

1. **可靠性最高**：不依赖AI理解，可以强制保证简化描写
2. **灵活性好**：可以选择不同的简化版本生成策略
3. **可扩展性强**：未来可以添加更多优化（如根据上下文动态简化）

### 实现难点和解决方案

#### 难点1：如何精确识别哪些条目被激活？

**解决方案**：
- 在 `GENERATION_STARTED` 时，通过以下方式预测：
  1. 关键词匹配：检查用户输入和聊天历史中的关键词，匹配条目的 `strategy.keys`
  2. 上下文分析：分析最近的对话主题，预测可能相关的条目
  3. **保守策略**：如果无法精确预测，则在生成后通过AI回复内容反推（在 `GENERATION_ENDED` 时分析）

#### 难点2：简化版本如何生成？

**解决方案**：
- **优先方案**：为每个条目类型设计简化模板
  ```typescript
  const SIMPLIFICATION_TEMPLATES = {
    '生活细节库': (original: string) => {
      // 提取前100字 + "（详细流程见之前描述）"
      return original.substring(0, 100) + '（详细流程见之前描述）';
    },
    '法律细节库': (original: string) => {
      // 提取关键法律要点
      return extractKeyPoints(original);
    },
    // ...
  };
  ```

- **备选方案**：首次详细描写时，让AI同时生成简化版本，存储到追踪表

#### 难点3：性能优化

**解决方案**：
1. 使用批量更新：一次性更新多个条目，而不是逐个更新
2. 使用缓存：简化版本生成后缓存，避免重复生成
3. 异步处理：简化版本生成和条目更新使用异步处理，不阻塞主流程

### 实现架构设计

```typescript
// 1. 扩展 WorldbookLoader 接口
interface WorldbookLoaderImpl {
  // ... 现有方法

  // 新增方法
  enableFirstTimeDetailedMode(libraryNames: string[]): void;
  trackEntryActivation(entryKey: string, day: number): void;
  isEntryFirstActivation(entryKey: string): boolean;
  getSimplifiedContent(entryKey: string): string | null;
  prepareWorldbooksForGeneration(context: string): Promise<void>;
  restoreWorldbooksAfterGeneration(): Promise<void>;
}

// 2. 追踪系统数据结构
interface EntryActivationState {
  activatedEntries: Set<string>; // entryKey集合
  firstActivationDay: Map<string, number>; // entryKey -> 首次激活天数
  activationCount: Map<string, number>; // entryKey -> 激活次数
}

// 3. 条目元数据扩展
interface ExtendedWorldbookEntry extends WorldbookEntry {
  extra?: {
    simplifiedContent?: string; // 简化版本内容
    needsTracking?: boolean; // 是否需要追踪
    libraryName?: string; // 所属库名称
  };
}
```

### 实现步骤

#### 阶段1：基础架构（1-2天）
1. 扩展 `WorldbookLoader` 接口
2. 创建追踪系统（存储到聊天变量）
3. 实现条目激活记录功能

#### 阶段2：简化版本生成（2-3天）
1. 设计简化模板或AI生成逻辑
2. 在加载世界书时生成简化版本
3. 存储到 `entry.extra.simplifiedContent`

#### 阶段3：动态替换逻辑（2-3天）
1. 在 `GENERATION_STARTED` 时预测可能激活的条目
2. 检查追踪表，判断是否需要简化
3. 使用 `updateWorldbookWith` 临时替换内容
4. 在 `GENERATION_ENDED` 时恢复

#### 阶段4：测试和优化（1-2天）
1. 测试各种场景
2. 性能优化
3. 处理边界情况

## 技术风险评估

### 高风险项
1. **无法精确识别激活的条目** - 风险等级：中
   - 缓解措施：使用保守策略，生成后反推，允许一定误差

2. **频繁修改世界书导致性能问题** - 风险等级：中
   - 缓解措施：批量更新、异步处理、缓存机制

3. **简化版本质量不足** - 风险等级：低
   - 缓解措施：设计多种简化策略，允许人工优化

### 低风险项
1. **状态持久化** - 已有成熟的聊天变量存储机制
2. **事件监听** - 已有 `GENERATION_STARTED` / `GENERATION_ENDED` 监听
3. **世界书API** - 已有完整的 `replaceWorldbook` / `updateWorldbookWith` API

## 结论

### 总体可行性：**高** ⭐⭐⭐⭐

**推荐方案**：方案C（混合方案 - 条目内容双重存储）

**关键成功因素**：
1. ✅ 技术可行：所有需要的API和机制都已存在
2. ✅ 实现复杂度：中等，需要仔细设计但可以实现
3. ✅ 性能影响：可控，通过优化可以接受
4. ✅ 用户体验：显著提升，避免重复冗长描写

**建议实施顺序**：
1. 先实现简化模板版本（快速验证可行性）
2. 然后优化为AI生成简化版本（提升质量）
3. 最后添加智能预测和性能优化（完善体验）

**预计开发时间**：7-10天（包括测试和优化）

---

## 附录：技术实现细节

### 条目唯一标识设计

```typescript
// 方案1：使用 worldbookName + entryUid
const entryKey = `${worldbookName}_${entry.uid}`;

// 方案2：使用 worldbookName + entryName（更易读，但可能重复）
const entryKey = `${worldbookName}_${entry.name}`;

// 推荐：方案1（唯一性保证）
```

### 简化版本生成示例

```typescript
function generateSimplifiedContent(original: string, libraryName: string): string {
  switch (libraryName) {
    case '生活细节库':
      // 提取前100字作为简化版本
      const simplified = original.substring(0, 100);
      return `${simplified}...（详细流程已在之前描述）`;

    case '法律细节库':
      // 提取法律要点
      const keyPoints = extractLegalPoints(original);
      return `法律要点：${keyPoints.join('、')}（详细内容见之前描述）`;

    case '环境描写库':
      // 提取环境关键词
      const envKeywords = extractEnvironmentKeywords(original);
      return `环境：${envKeywords.join('、')}（详细描写见之前）`;

    default:
      // 通用简化：提取前80字
      return original.substring(0, 80) + '...（详见之前描述）';
  }
}
```

### 追踪系统持久化示例

```typescript
// 保存到聊天变量
const tracker: EntryActivationState = {
  activatedEntries: new Set(['internal_basic_procedures_0', 'internal_basic_legal_5']),
  firstActivationDay: new Map([
    ['internal_basic_procedures_0', 1],
    ['internal_basic_legal_5', 3],
  ]),
  activationCount: new Map([
    ['internal_basic_procedures_0', 2],
    ['internal_basic_legal_5', 1],
  ]),
};

// 保存（需要转换为可序列化格式）
updateVariablesWith(
  variables => ({
    ...variables,
    worldbookEntryTracker: {
      activatedEntries: Array.from(tracker.activatedEntries),
      firstActivationDay: Object.fromEntries(tracker.firstActivationDay),
      activationCount: Object.fromEntries(tracker.activationCount),
    },
  }),
  { type: 'chat' },
);
```
